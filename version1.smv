MODULE main
VAR
  state : {wait_connect_rsp, closed, wait_config, wait_connect, wait_final_rsp, open, wait_control_ind, wait_config_req, wait_send_config, wait_config_req_rsp, wait_ind_final_rsp, wait_config_rsp};
  -- this ^ is an enumeration of states; all the states that exist

  --now inputs
  --TODO FIGURE OUT DIFFERENCE BETWEEN EVENTS AND ACTIONS
  --these are inputs that can either be T/F at any point - those T/F values are used in case/next evaluation
  l2_connectrsp: boolean;
  l2_connectreq: boolean;
  --NOT YET EXHAUSTIVE THIS IS JUST TWO THERE ARE LIKE 30

ASSIGN
  init(state) := wait_connect_rsp; -- inital / starting state 
  next(state) := case
		    --"else"
		    --state = ready & request = FALSE : ready;  --this and other case are basically do nothing without request
		    --state = busy : busy;
		    state = wait_connect_rsp & l2_connectrsp = TRUE : wait_config;
		    -- this ^ says if the state is currently wait_connect_rsp
		    -- and the l2_connectrsp is TRUE, then set the state to wait_config

		    --"else"
		    TRUE : wait_config; -- this is saying 'if not the above case, then just set the state to wait_config this is a placeholder
		    --because if case conditions are NOT exhaustive/comprehensive then NuSMV throws a temper tantrum. 
		  esac;  --end of case statements 
		  --TODO need to figure out how to do this for other states because typing this out exhaustively is CANONICALLY IMPOSSIBLE FR 

--assertions
LTLSPEC G(state=wait_connect_rsp -> F(state=wait_config));
--this is the 'liveness' property, saying that globally (G), eventually (F), 
--whenever the system is in the 'wait_connect_rsp' state, it must at some point be in the 'wait_config' state.
--normally it should be false in the case that no input is ever recieved, but because of our failsafe it should be confirmed by NuSMV
